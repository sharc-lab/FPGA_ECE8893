<a name="br1"></a>**Readme**

For this project we don’t have any Python or Golden C ﬁles since there were no reference
implementations available to us. The project has been written from scratch from our own understanding
of how a row stationary convolution might work using the Eyeriss Row stationary paper ’s theory as
reference.

**Code structure and Description:**

The code structure mainly has three ﬁles:

• Convolution.cpp – contains the PE structure and its related methods like reset,
 read\_data\_DRAM, write\_data\_DRAM to read and write data from DRAM, sum\_of\_psums
 perform the ﬁnal set of summations from the generated partial sums, processing\_element which
 performs the data sharing on systolic array and funcꢀonal implementation of individual PEs,
 convoluꢀon function which is the outermost method and calls the processing\_element method
 for every operation cycle.

• Convolution.h – which deﬁnes the PE parameters like buﬀer\_size, systolic array grid size, input
 array size, kernel size, output array size etc. The code is highly scalable. Hence the design
 parameters can be modiﬁed in this header ﬁle. Incase you want to run the design for a larger
 input size, please change the input length (IF\_LENGTH) and breadth (OP\_BREADTH) and the
 output length (OP\_LENGTH) and breadth (OP\_BREADTH). The code will handle the necessary
 folding to accommodate for the increased output needed to be produced despite the ﬁxed size
 of the systolic array.

• Testbench.cpp – The data passing to the convolution code is done here and the folding logic to
 support scalability is also implemented here. This also produces the golden output required for
 the comparison of the data from the implementaꢀon and the actual expected data and ﬁnally
 intimates us if the test case has passed. The inputs that are fed to the design are random
 integers generated by a random function.

**How to run the code:**

It needs to be on the ece-linlabs server with Vitis installed.
The IDE needs to have proper included paths to the Vitis includes present so that it can pick up
hls\_stream.h and other header ﬁles needed for our FIFOs.

Step 1: C simulation

Go to the relevant folder where all the ﬁles are present and just type make. Then type ./csim.out to test
if the Vitis HLS funcꢀon is functionally correct.

Step 2: C synthesis

Go to the relevant folder and type make synth. This internally runs: vitis\_hls script.tcl. The reports and
solutions are formed as usual inside the proj/solution1 directory.

The theory of row stationary data flow is present in the below paper.

Y. -H. Chen, J. Emer and V. Sze, "Eyeriss: A Spatial Architecture for Energy-Efficient Dataflow for
Convolutional Neural Networks," 2016 ACM/IEEE 43rd Annual International Symposium on Computer
Architecture (ISCA), Seoul, Korea (South), 2016, pp. 367-379, doi: 10.1109/ISCA.2016.40.

We are willing to open source our code.
